
- [Bitcoin-区块链技术的起源](#bitcoin-区块链技术的起源)
  - [非对称加密](#非对称加密)
  - [时间戳服务器](#时间戳服务器)
  - [Merkle Tree](#merkle-tree)
  - [工作量证明(POW)](#工作量证明pow)
    - [拜占庭将军问题](#拜占庭将军问题)
    - [工作量证明谜题](#工作量证明谜题)
    - [矿机](#矿机)
    - [权益证明(POS)](#权益证明pos)


# Bitcoin-区块链技术的起源
2008 年 10 月 31 日，中本聪（Satoshi Nakamoto）发布了[比特币白皮书][1]。

## 非对称加密
使用非对称加密的公私钥体系设计账户，公钥就是账户地址，持有私钥的人可以通过签名交易来支配账户里的资产。签名后的交易被广播到网络中，等待矿工打包。（保证了签名不可伪造也不可抵赖）

<img src="bc01.svg" width="600" />

## 时间戳服务器
每次打包一些交易（最多 1MB 大小）会形成一个`区块(block)`，根据区块头的内容加上`时间戳(timestamp)`可以算出这个区块的哈希值，同时区块头里有一个指向前一区块的哈希值，从而这些不断增长的区块可以串接起来形成单向有序链表（区块链）。所有历史交易记录都保存在区块链中。

全网所有节点地位相同，都持有这个账本的全量数据，账本内容完全公开可追溯。这样就形成了一个全局账本，确保同一枚比特币不会被`双重支付`。

<img src="bc02.svg" width="600" />

## Merkle Tree
区块体里存放了这次打包的 N 笔交易，所有交易按规则生成一个Merkle Tree，每个区块头里有个 merkle root 字段记录默克尔树的根，来保证区块体交易不可篡改。

<img src="bc03.jpeg" width="600" />

Merkle Tree的特点：任何一个叶子结点被篡改，会被立刻发现

<img src="bc04.jpg" width="600" />

如果一枚硬币最近发生的交易发生在足够多的区块之前，那么，这笔交易之前该硬币的花销交易记录可以被丢弃 —— 目的是为了节省磁盘空间。

<img src="bc05.svg" width="600" />

## 工作量证明(POW)
有些节点是矿工，负责把网络中的交易打包到账本中，并赚取打包的奖励和交易手续费。矿工打包出的区块除了满足数据的合法性要求（交易内容都是可以通过验证的），还需要给出一个`工作量证明`。

### 拜占庭将军问题
`拜占庭将军问题`是Leslie Lamport（2013年的图灵讲得住）用来为描述分布式系统一致性问题（Distributed Consensus）在[论文][2]中抽象出来一个的例子。

>拜占庭帝国想要进攻一个强大的敌人，为此派出了10支军队去包围这个敌人。这个敌人虽不比拜占庭帝国，但也足以抵御5支常规拜占庭军队的同时袭击。这10支军队在分开的包围状态下同时攻击。他们任一支军队单独进攻都毫无胜算，除非有至少6支军队（一半以上）同时袭击才能攻下敌国。他们分散在敌国的四周，依靠通信兵骑马相互通信来协商进攻意向及进攻时间。困扰这些将军的问题是，他们不确定他们中是否有叛徒，叛徒可能擅自变更进攻意向或者进攻时间。在这种状态下，拜占庭将军们才能保证有多于6支军队在同一时间一起发起进攻，从而赢取战斗？

说明：
1. 拜占庭将军问题中并不去考虑通信兵是否会被截获或无法传达信息等问题，即消息传递的信道绝无问题。Lamport已经证明了在消息可能丢失的不可靠信道上试图通过消息传递的方式达到一致性是不可能的。（计算机网络通讯中TCP协议保障）
2. Lamport提出的Paxos算法或其衍生算法(ZooKeeper/Chubby等系统支持)仅适用于中心化的分布式系统，这样的系统的没有不诚实的节点（不会发送虚假错误消息，但允许出现网络不通或宕机出现的消息延迟）。

中本聪通过引入`工作量证明(POW:Proof of Work)`来解决不诚实节点的问题，使得在P2P网络中可以保证一致性。

### 工作量证明谜题
>找到一个`nonce值`，使得新区块头的哈希值小于某个指定的值，即区块头结构中的“难度目标”。在节点成功找到满足的Hash值 之后，会马上对全网进行广播打包区块，网络的节点收到广播打包区块，会立刻对其进行验证。

如果验证通过，则表明已经有节点成功解迷，自己就不再竞争当前区块打包，而是选择接受这个区块，记录到自己的账本中，然后进行下一个区块的竞争猜谜。

计算过程类似：

```py
for nonce in range(0, 2**32):
    block_header = version + previous_block_hash + merkle_root + timestamp + target_bits + nonce
    if HASH(block_header) < target_bits: 
        break
    else: 
        continue
```

说明：

target_bits，用来控制挖矿难度（比特币期望出块的平均时间是10分钟，每14天整个比特币系统会根据之前出块速度调整全网难度来靠近 10 分钟。）

```
目标值 = 最大目标值 / 难度值
最大目标值=0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF

新难度值 = 旧难度值 * ( 过去2016个区块花费时长 / 20160 分钟 )
```

实际挖矿的基本步骤：

1. 生成Coinbase交易，并与其他所有准备打包进区块的交易组成交易列表，并生成默克尔哈希;
2. 把默克尔哈希及其他相关字段组装成区块头，将区块头(Block Header)作为工作量证明的输入，区块头中包含了前一区块的哈希，区块头一共80字节数据;
3. 不停地变更区块头中的随机数即nonce的数值，也就是暴力搜索，将结果值与当前网络的目标值做对比，如果小于目标值，则解题成功，工作量证明完成。

在指定时间内，给定一个难度，找到答案的概率唯一地由所有参与者能够迭代哈希的速度决定。掌握51%的算力对系统进行攻击所付出的代价远远大于作为一个系统的维护者和诚实参与者所得到的。

### 矿机
PoW挖矿算法大致分为两个大类，第一类叫计算困难，第二类内存困难。计算机的组成分为计算单元和存储单元，一个计算机的瓶颈往往是IO，如果要制造大量的IO操作，可以通过写程序撑大内存，制造大量的数据处理过程，使工作量证明从计算单元转变为 存储单元。

- 计算困难型：Scrypt、X11、SHA-3
- 内存困难型：ETHASH（Dagger-Hashimoto的修改版本,以太坊的PoW挖矿算法）

矿机演进：CPU-GPU-FPGA-ASIC专业芯片(高性能计算)+矿池（分布式计算）

### 权益证明(POS)
PoS全称是Proof of Stake，⽬的就是为了解决使⽤PoW挖矿出现⼤量资源浪费的问题。

在PoS系统中，这个公式变更为： Hash(block_header) < target_bits * CoinAge。

说明：
- CoinAge(币龄)，字⾯意思就是币数量乘以持有天数。如果你的币龄越⼤，也就意味着你的获得答案越容易。

问题
1. 冷启动问题。
2. 囤积问题，这会造成币流通的不充分（通货紧缩）。
3. Nothing at Stake，翻译过来叫做⽆成本利益问题。⼤体的意思在PoS系统中做任何事⼏乎没有成本，⽐如在PoS系统上挖矿⼏乎没有成本，这也就意味着分叉⾮常⽅便。（反正也没什么成本，反正分叉链和主链都可以同时挖，说不定什么时候就值钱了）
4. 价值观理念










[1]:https://bitcoin.org/bitcoin.pdf "《Bitcoin: A Peer-to-Peer Electronic Cash System》"
[2]:http://lamport.azurewebsites.net/pubs/byz.pdf "The Byzantine Generals Problem"
